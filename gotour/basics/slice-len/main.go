package main

import "fmt"

/*
*
切片的长度与容量

切片拥有 长度 和 容量。

切片的长度就是它所包含的元素个数。
切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。
切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。
你可以通过重新切片来扩展一个切片，给它提供足够的容量。 试着修改示例程序中的切片操作，向外扩展它的长度，看看会发生什么。
*/
func main() {
	// ========== 初始状态 ==========
	// 【Go vs Java】切片 vs 数组/列表
	// Java:  int[] arr = {2, 3, 5, 7, 11, 13};  // 数组固定长度
	//        List<Integer> list = Arrays.asList(...);  // 列表可变
	// Go:    s := []int{2, 3, 5, 7, 11, 13}  // 切片（底层是数组）
	//
	// 重要概念：
	// - 切片是底层数组的"视图"（view）
	// - 切片包含：指针（指向底层数组）、长度（len）、容量（cap）
	// - 底层数组：实际存储数据的地方 [2, 3, 5, 7, 11, 13]
	// - 切片"窗口"：当前能看到的部分
	//
	// 初始状态：
	// 底层数组: [2, 3, 5, 7, 11, 13]
	// 切片窗口: [2, 3, 5, 7, 11, 13]  ← 全部可见
	// len=6, cap=6
	s := []int{2, 3, 5, 7, 11, 13}
	printSlice(s) // 输出: len=6 cap=6 [2 3 5 7 11 13]

	// ========== 关键操作1：截取到长度为0 ==========
	// 【Go vs Java】切片截取不会删除数据
	// Java:  如果截取数组，需要创建新数组（旧数据可能被GC回收）
	// Go:    s[:0] 只是改变"窗口"大小，底层数组数据还在！
	//
	// 执行 s = s[:0] 后：
	// 底层数组: [2, 3, 5, 7, 11, 13]  ← 数据还在！
	// 切片窗口: []  ← 窗口缩小到0（看不到任何元素，但数据没删）
	// len=0, cap=6（容量不变，因为底层数组还在）
	//
	// 类比：就像把窗户完全关上（len=0），但房子里的东西（底层数组）还在
	// 截取切片使其长度为 0
	s = s[:0]
	printSlice(s) // 输出: len=0 cap=6 []
	// ⚠️ 注意：虽然切片长度为0，但底层数组的数据 [2,3,5,7,11,13] 还在！

	// ========== 关键操作2：扩展回长度4 ==========
	// 【回答你的问题】是的！原来的值可以自动填充回来！
	//
	// 执行 s = s[:4] 后：
	// 底层数组: [2, 3, 5, 7, 11, 13]  ← 数据一直在这里
	// 切片窗口: [2, 3, 5, 7]  ← 窗口扩展到能看到前4个元素
	// len=4, cap=6
	//
	// 原因：切片只是底层数组的"视图"
	// - s[:0] 只是把窗口缩到最小（但数据还在底层数组里）
	// - s[:4] 把窗口重新打开，就能看到原来的数据了
	// 扩展其长度
	s = s[:4]
	printSlice(s) // 输出: len=4 cap=6 [2 3 5 7]
	// ✅ 看到了吗？原来的值 [2, 3, 5, 7] 又回来了！

	// ========== 操作3：舍弃前两个值 ==========
	// 【Go vs Java】改变切片的起始位置
	// Java:  int[] sub = Arrays.copyOfRange(s, 2, s.length);
	// Go:    s = s[2:]
	//
	// 执行 s = s[2:] 后：
	// 底层数组: [2, 3, 5, 7, 11, 13]  ← 数据还在
	// 切片窗口: [5, 7]  ← 窗口从索引2开始，看到 [5, 7]
	// len=2, cap=4（容量变成4，因为从索引2开始，后面还有4个位置）
	//
	// 注意：虽然窗口移到了索引2，但底层数组的前面 [2, 3] 数据还在
	// 只是窗口看不到它们了（容量减少了）
	// 舍弃前两个值
	s = s[2:]
	printSlice(s) // 输出: len=2 cap=4 [5 7]
}

// ========== 核心总结 ==========
// 切片的关键特性：
// 1. 切片是底层数组的"视图"，不是数据的副本
// 2. s[:0] 只是改变窗口大小，不删除数据
// 3. 只要容量足够（cap >= 新长度），就可以扩展回去看到原来的数据
// 4. 容量（cap）是从切片起始位置到底层数组末尾的长度
// 5. 长度（len）是当前能看到多少个元素

// printSlice 打印切片的长度、容量和内容
// 【Go vs Java】内置函数
// Java:  System.out.printf("len=%d cap=%d %s\n", s.length, s.capacity, Arrays.toString(s));
// Go:    fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
// 注意：len() 和 cap() 是Go的内置函数，不是方法
func printSlice(s []int) {
	// len(s) - 切片的长度（当前元素个数）
	// cap(s) - 切片的容量（从起始位置到底层数组末尾的元素个数）
	// %v - 通用格式化动词，打印切片内容
	fmt.Printf("len=%d cap=%d %v\n", len(s), cap(s), s)
}
