package main

import "fmt"

/*
*

函数闭包
Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。 该函数可以访问并赋予其引用的变量值，换句话说，该函数被“绑定”到了这些变量。

例如，函数 adder 返回一个闭包。每个闭包都被绑定在其各自的 sum 变量上。
*/
// ========== 闭包函数：返回一个函数 ==========
// adder 函数返回一个闭包（closure）
// 【Go vs Java】函数返回函数
// Java:  Function<Integer, Function<Integer, Integer>> adder = () -> {
//            final int[] sum = {0};  // 需要用数组或对象来修改
//            return (x) -> {
//                sum[0] += x;
//                return sum[0];
//            };
//        };
//
// Go:    func adder() func(int) int { ... }
//
// 函数签名说明：
// - adder() 是函数名
// - func(int) int 是返回类型（一个函数类型）
//   - 接收一个 int 参数
//   - 返回一个 int 值
//
// 闭包的核心概念：
// - 内部函数可以访问外部函数的变量
// - 变量 sum 被"捕获"并绑定到返回的函数
// - 每次调用 adder() 都会创建一个新的 sum 变量
func adder() func(int) int {
	// 【关键】局部变量 sum，被内部函数捕获
	// 这个变量会一直存在于闭包中，即使 adder() 函数执行完毕
	sum := 0

	// 返回一个匿名函数（闭包）
	// 这个函数"记住"并可以修改 sum 变量
	return func(x int) int {
		// sum 变量来自外部函数 adder()
		// 这是闭包的关键：内部函数可以访问外部作用域的变量
		sum += x // 累加：sum = sum + x
		return sum
	}
	// 注意：即使 adder() 执行完毕，sum 变量也不会被销毁
	// 它被"绑定"到返回的函数上，随函数一起存在
}

func main() {
	// ========== 创建两个独立的闭包实例 ==========
	// 【Go vs Java】创建闭包实例
	// Java:  Function<Integer, Integer> pos = adder().apply();
	//        Function<Integer, Integer> neg = adder().apply();
	//
	// Go:    pos, neg := adder(), adder()
	//
	// 重要：每次调用 adder() 都会创建一个新的闭包
	// - pos 和 neg 是两个完全独立的闭包
	// - 它们各自拥有自己的 sum 变量（初始值都是0）
	// - 它们互不影响，各自维护自己的状态
	//
	// pos 的闭包：sum = 0（独立）
	// neg 的闭包：sum = 0（独立，与 pos 无关）
	pos, neg := adder(), adder()

	// ========== 使用闭包 ==========
	// 执行过程（前几次迭代）：
	//
	// i=0: pos(0)  → pos的sum: 0+0=0，返回0
	//      neg(-0) → neg的sum: 0+0=0，返回0
	//      输出：0 0
	//
	// i=1: pos(1)  → pos的sum: 0+1=1，返回1
	//      neg(-2) → neg的sum: 0+(-2)=-2，返回-2
	//      输出：1 -2
	//
	// i=2: pos(2)  → pos的sum: 1+2=3，返回3
	//      neg(-4) → neg的sum: -2+(-4)=-6，返回-6
	//      输出：3 -6
	//
	// ...以此类推
	for i := 0; i < 10; i++ {
		fmt.Println(
			pos(i),    // 调用 pos 闭包，累加 i
			neg(-2*i), // 调用 neg 闭包，累加 -2*i
		)
	}
	// 输出：
	// 0 0
	// 1 -2
	// 3 -6
	// 6 -12
	// 10 -20
	// 15 -30
	// 21 -42
	// 28 -56
	// 36 -72
	// 45 -90
}

// ========== 闭包的核心概念总结 ==========
// 1. 闭包（Closure）是什么？
//    - 函数可以访问并修改其外部作用域的变量
//    - 即使外部函数执行完毕，变量也不会被销毁
//    - 变量被"绑定"到闭包函数上
//
// 2. 为什么 pos 和 neg 是独立的？
//    - 每次调用 adder() 都创建一个新的 sum 变量
//    - 每个闭包捕获的是自己的 sum 变量
//    - 它们互不干扰，各自维护状态
//
// 3. 闭包的应用场景：
//    - 状态管理（如计数器、累加器）
//    - 函数工厂（生成不同配置的函数）
//    - 延迟执行（捕获上下文）
//
// 4. 与 Java 的对比：
//    - Java 的 Lambda 也可以形成闭包
//    - 但 Java 要求捕获的变量必须是 final 或 effectively final
//    - Go 的闭包更灵活，可以直接修改捕获的变量
//
// 5. 注意事项：
//    - 闭包会导致变量生命周期延长（可能影响内存）
//    - 在循环中使用闭包时要注意变量捕获的问题
