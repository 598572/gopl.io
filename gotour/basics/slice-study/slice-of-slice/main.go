package main

import (
	"fmt"
	"strings"
)

/*
*
切片的切片
切片可以包含任何类型，当然也包括其他切片。
*/
func main() {
	// ========== 创建二维切片（切片的切片）==========
	// 【Go vs Java】二维数组/切片
	// Java:  String[][] board = new String[3][3];
	//        或者 String[][] board = {{"_", "_", "_"}, {"_", "_", "_"}, {"_", "_", "_"}};
	// Go:    board := [][]string{...}
	//
	// 解释：
	// - [][]string 表示"切片的切片"，即二维切片
	//   - 外层 [] 表示这是一个切片
	//   - 内层 []string 表示这个切片包含的元素类型是 []string（字符串切片）
	// - 相当于：一个切片，里面每个元素又是一个字符串切片
	//
	// 结构示意：
	// board[0] → []string{"_", "_", "_"}  (第一行)
	// board[1] → []string{"_", "_", "_"}  (第二行)
	// board[2] → []string{"_", "_", "_"}  (第三行)
	//
	// 访问方式：board[行索引][列索引]
	// 例如：board[0][0] 表示第0行第0列的元素
	//
	// 创建一个井字棋（经典游戏）
	board := [][]string{
		[]string{"_", "_", "_"}, // 第0行：3个空位
		[]string{"_", "_", "_"}, // 第1行：3个空位
		[]string{"_", "_", "_"}, // 第2行：3个空位
	}
	// 初始化后的棋盘：
	//   _ _ _
	//   _ _ _
	//   _ _ _

	// ========== 玩家下棋（修改二维切片元素）==========
	// 【Go vs Java】访问二维数组元素
	// Java:  board[0][0] = "X";
	// Go:    board[0][0] = "X"  (语法相同)
	//
	// 井字棋坐标系统：
	//   (0,0) (0,1) (0,2)
	//   (1,0) (1,1) (1,2)
	//   (2,0) (2,1) (2,2)
	//
	// 两个玩家轮流打上 X 和 O
	board[0][0] = "X" // 玩家X在左上角下棋
	// 棋盘状态：
	//   X _ _
	//   _ _ _
	//   _ _ _

	board[2][2] = "O" // 玩家O在右下角下棋
	// 棋盘状态：
	//   X _ _
	//   _ _ _
	//   _ _ O

	board[1][2] = "X" // 玩家X在中间行最右边下棋
	// 棋盘状态：
	//   X _ _
	//   _ _ X
	//   _ _ O

	board[1][0] = "O" // 玩家O在中间行最左边下棋
	// 棋盘状态：
	//   X _ _
	//   O _ X
	//   _ _ O

	board[0][2] = "X" // 玩家X在第一行最右边下棋
	// 最终棋盘状态：
	//   X _ X
	//   O _ X
	//   _ _ O

	// ========== 打印棋盘 ==========
	// 【Go vs Java】遍历二维数组
	// Java:  for (int i = 0; i < board.length; i++) {
	//            System.out.println(String.join(" ", board[i]));
	//        }
	// Go:    for i := 0; i < len(board); i++ { ... }
	//
	// 解释：
	// - len(board) 返回外层切片的长度（行数，这里是3）
	// - board[i] 获取第i行的切片（类型是 []string）
	// - strings.Join(board[i], " ") 将第i行的所有元素用空格连接成字符串
	//   例如：["X", "_", "X"] → "X _ X"
	for i := 0; i < len(board); i++ {
		// 【Go vs Java】字符串连接
		// Java:  String.join(" ", board[i])
		// Go:    strings.Join(board[i], " ")
		// 注意：strings.Join 是 Go 的标准库函数，用于连接字符串切片
		fmt.Printf("%s\n", strings.Join(board[i], " "))
	}
	// 输出结果：
	//   X _ X
	//   O _ X
	//   _ _ O
}

// ========== 核心概念总结 ==========
// 1. [][]string 是"切片的切片"，即二维切片
// 2. 可以理解为：一个切片，每个元素又是一个切片
// 3. 访问方式：board[行][列]
// 4. Go 的二维切片比 Java 的二维数组更灵活（每行长度可以不同）
//
// 扩展：Go 的二维切片每行长度可以不同（不规则切片）
// 例如：
//   board := [][]string{
//       []string{"_", "_"},           // 第0行：2个元素
//       []string{"_", "_", "_", "_"}, // 第1行：4个元素
//       []string{"_"},                // 第2行：1个元素
//   }
// 这在 Java 中需要特殊处理，Go 中很自然
