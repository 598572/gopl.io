package main

import "fmt"

/*
*
**切片的默认行为**

在进行切片时，你可以利用它的默认行为来忽略上下界。

切片下界的默认值为 0，上界则是该切片的长度。

对于数组

var a [10]int
来说，以下切片表达式和它是等价的：

a[0:10]
a[:10]
a[0:]
a[:]
*/
func main() {
	// ========== 初始状态 ==========
	// 创建一个包含6个元素的切片
	// 【Go vs Java】切片初始化
	// Java:  int[] s = {2, 3, 5, 7, 11, 13};
	// Go:    s := []int{2, 3, 5, 7, 11, 13}
	//
	// 初始切片：索引  0  1  2  3   4   5
	//          值   [2, 3, 5, 7, 11, 13]
	s := []int{2, 3, 5, 7, 11, 13}

	// ========== 第一步：s[1:4] ==========
	// 【Go vs Java】切片操作
	// Java:  int[] sub = Arrays.copyOfRange(s, 1, 4);  // [3, 5, 7]
	// Go:    s = s[1:4]
	//
	// 解释：
	// - s[1:4] 表示从索引1开始，到索引4结束（不包括4）
	// - 这是"左闭右开"区间：[1, 4)
	// - 取出的元素：索引1(值3)、索引2(值5)、索引3(值7)
	// - 结果：s 现在指向 [3, 5, 7]
	//
	// 原始：索引 0  1  2  3   4   5
	//      值  [2, 3, 5, 7, 11, 13]
	//            └─────┬─────┘
	//                 取这些：s[1:4] = [3, 5, 7]
	s = s[1:4]
	fmt.Println(s) // 输出: [3 5 7]
	// 注意：现在 s 的长度是3，包含元素 [3, 5, 7]

	fmt.Println(s) // 再次打印，还是 [3 5 7]（重复代码，可能是示例错误）

	// ========== 第二步：s[:2] ==========
	// 【Go vs Java】切片默认下界
	// Java:  int[] sub = Arrays.copyOfRange(s, 0, 2);
	// Go:    s = s[:2]
	//
	// 解释：
	// - s[:2] 表示从开头（索引0）到索引2（不包括2）
	// - 等价于 s[0:2]
	// - 默认下界是0，所以可以省略
	// - 取出的元素：索引0(值3)、索引1(值5)
	// - 结果：s 现在指向 [3, 5]
	//
	// 当前s：索引 0  1  2
	//       值  [3, 5, 7]
	//           └───┘
	//           取这些：s[:2] = [3, 5]
	s = s[:2]
	fmt.Println(s) // 输出: [3 5]

	// ========== 第三步：s[1:] ==========
	// 【Go vs Java】切片默认上界
	// Java:  int[] sub = Arrays.copyOfRange(s, 1, s.length);
	// Go:    s = s[1:]
	//
	// 解释：
	// - s[1:] 表示从索引1到末尾（包括最后一个元素）
	// - 等价于 s[1:len(s)]
	// - 默认上界是切片的长度，所以可以省略
	// - 取出的元素：索引1(值5)
	// - 结果：s 现在指向 [5]
	//
	// 当前s：索引 0  1
	//       值  [3, 5]
	//              └──┘
	//           取这些：s[1:] = [5]
	s = s[1:]
	fmt.Println(s) // 输出: [5]

	// ========== 总结 ==========
	// 切片语法规则：
	// 1. s[low:high]  - 从low到high（不包括high），左闭右开
	// 2. s[:high]     - 等价于 s[0:high]，从开头到high
	// 3. s[low:]      - 等价于 s[low:len(s)]，从low到末尾
	// 4. s[:]         - 等价于 s[0:len(s)]，整个切片（复制）
	//
	// 重要提示：
	// - 切片操作不会创建新的底层数组，只是改变了"视图"
	// - 修改切片的元素会影响原始数组/切片（如果它们共享底层数组）
	// - 每次切片操作后，切片的长度和容量可能会改变
}
